{{define "publicUpload"}}{{template "header" .}}

 
 <style>
 
.pu-file-list {
    margin-top: 1.5rem;
  }

  .pu-file-item {
    display: flex;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 0.95rem;
  }

  .pu-file-item .file-name {
    flex: 1;
    text-align: left;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    margin-right: 1rem;
  }


  .pu-file-item .upload-status {
    width: 300px; 
    text-align: right;
    margin-right: 1rem;
    flex-shrink: 0;
    opacity: 0.75;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .pu-file-item .file-size {
    width: 80px;
    text-align: right;
    margin-right: 12px;
    flex-shrink: 0;
    opacity: 0.75;
  }

</style>

<main style="margin-top: 2rem">
  <div class="row justify-content-center">
    <div class="col-lg-8">
      <div class="card bg-dark text-white">
        <div class="card-body">
          <h3 class="card-title text-center mb-4">Upload Files</h3>
{{ if ne .FileRequest.Notes "" }}
          <div class="info-box">
            <h6>Note</h6>
            <p class="mb-0">{{.FileRequest.Notes}}</p>
          </div>
{{ end }}
{{ if .FileRequest.HasRestrictions }}
          <div class="info-box">
            <h6>Upload restrictions</h6>
            <ul>
    {{ if not (.FileRequest.IsUnlimitedTime) }}
              <li>Upload possible until: <strong>
                  <span id="expirydate">{{ .FileRequest.Expiry }}</span>
                </strong>
              </li>
              <script>
                insertFormattedDate({{.FileRequest.Expiry}}, "expirydate");
              </script>
   {{ end }}
   {{ if or (not (.FileRequest.IsUnlimitedSize)) (lt .FileRequest.CombinedMaxSize 5000) }}
              <li>Maximum file size: <strong>
                  <span id="maxfilesize"></span>
                </strong>
              </li>
              <script>
                insertReadableSize({{.FileRequest.CombinedMaxSize}}, 1024 * 1024, "maxfilesize");
              </script>
   {{ end }}
       {{ if not (.FileRequest.IsUnlimitedFiles) }}
              <li>Maximum number of files: <strong>{{ .FileRequest.FilesRemaining }}</strong>
              </li>
       {{ end }}
            </ul>
          </div>
{{ end }}
          <label for="fileInput" class="upload-box text-center w-100">
            <p class="mb-2 fs-5">Drag & drop files here</p>
            <p class="mb-0 opacity-75">or paste or click to select</p>
            <input type="file" id="fileInput" class="d-none" multiple>
          </label>
          <div id="fileList" class="pu-file-list"></div>
          <div class="text-center mt-4">
            <button class="btn btn-secondary" onClick="initUpload();" id="uploadbutton"> Upload </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>


<!-- Error Modal -->
<div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
  <div class="modal-dialog gokapi-dialog">
    <div class="modal-content gokapi-dialog">
      <div class="modal-header">
        <h2 class="modal-title fs-5" id="errorModalLabel">Unable to upload</h2>
      </div>
      <div class="modal-body">
        <span id="span-modal-error"></span>
      </div>
      <div class="modal-footer">
        <button type="button" data-bs-dismiss="modal" data-bs-target="#errorModal" class="btn btn-primary">Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- All Uploaded Modal -->
<div class="modal fade" id="allUploadedModal" tabindex="-1" aria-labelledby="allUModalLabel" aria-hidden="true">
  <div class="modal-dialog gokapi-dialog">
    <div class="modal-content gokapi-dialog">
      <div class="modal-header">
        <h2 class="modal-title fs-5" id="allUModalLabel">Success</h2>
      </div>
      <div class="modal-body">
        All files have been successfully uploaded. No further files can be uploaded anymore. You can close this page now.
      </div>
      <div class="modal-footer">
      </div>
    </div>
  </div>
</div>



<script>

const fileInput = document.getElementById('fileInput');
const fileList = document.getElementById('fileList');
const filesMap = new Map();
const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));


fileInput.addEventListener('change', () => {
    Array.from(fileInput.files).forEach(file => {

        if (file.size > MAX_FILE_SIZE) {
            document.getElementById('span-modal-error').innerText =
                `The file "${file.name}" exceeds the maximum allowed size of ${formatSize(MAX_FILE_SIZE)}.`;
            errorModal.show();
            return;
        }

        const uuid = getUuid();

        const item = document.createElement('div');
        item.className = 'pu-file-item';
        item.dataset.uuid = uuid;

        const name = document.createElement('span');
        name.textContent = file.name;
        name.className = 'file-name';

        const progressText = document.createElement('span');
        progressText.className = 'upload-status';
        progressText.textContent = 'Ready';

        const progressBar = document.createElement('progress');
        progressBar.className = 'upload-progress';
        
        if (file.size == 0) {
            progressBar.max = 1;
        } else {
            progressBar.max = file.size;
        }
        progressBar.value = 0;

        const size = document.createElement('span');
        size.className = 'file-size';
        size.textContent = formatSize(file.size);

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.title = 'Remove';
        removeBtn.className = 'btn btn-sm btn-link text-light p-0';
        removeBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
        removeBtn.onclick = () => {
            filesMap.get(uuid).removed = true;
            item.remove();
        };

        item.append(name, progressText, progressBar, size, removeBtn);
        fileList.appendChild(item);

        filesMap.set(uuid, {
            uuid,
            file,
            removed: false,
            elements: {
                progressBar,
                progressText,
                removeBtn,
                item
            }
        });
    });
    // Allow re-selecting same files
    fileInput.value = '';
});

function showModal(modalCode) {
    let message = "";
    switch (modalCode) {
    
        case "alluploaded":
            new bootstrap.Modal(document.getElementById('allUploadedModal'), {
                keyboard: false,
                backdrop: "static"
            }).show();
            return;
            
        case "maxfiles":
            if (maxFilesRemaining == 1) {
                message = "Too many files are selected for upload. Please only select 1 file.";
            } else {
                message = "Too many files are selected for upload. Please only select " + maxFilesRemaining + " files or fewer.";
            }
            break;
            
        case "maxfilesdynamic":
            message = "Some files could not be uploaded because the server rejected the request. This likely occurred because another user was uploading files at the same time and the maximum file limit was reached.";
            break;
            
        case "expired":
            message = "The upload request exceeded the permitted time limit, and uploading additional files is no longer possible.";
            break;
    }
    document.getElementById('span-modal-error').innerText = message;
    errorModal.show();
}

function formatSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let i = 0;
    while (bytes >= 1024 && i < units.length - 1) {
        bytes /= 1024;
        i++;
    }
    return bytes.toFixed(1) + ' ' + units[i];
}

const CHUNK_SIZE = {{.ChunkSize}} * 1024 * 1024;
const API_BASE = "./api/uploadrequest/chunk/";
const RESERVE_URL = API_BASE + "reserve";
const UPLOAD_URL = API_BASE + "add";
const COMPLETE_URL = API_BASE + "complete";
const FILE_REQUEST_ID = "{{ .FileRequest.Id }}";
const API_KEY = "{{ .FileRequest.ApiKey }}";
const MAX_FILE_SIZE = {{.FileRequest.CombinedMaxSize}} * 1024 * 1024;
const IS_UNLIMITED_FILES = {{ .FileRequest.IsUnlimitedFiles }};
const IS_UNLIMITED_TIME = {{ .FileRequest.IsUnlimitedTime }};
var maxFilesRemaining = {{.FileRequest.FilesRemaining}};


async function withRetry(fn, {
    retries = 3,
    retryDelay = 5000,
    onRetry
} = {}) {
    let lastError;
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            return await fn();
        } catch (err) {
            lastError = err;
            if (onRetry && attempt < retries) {
                onRetry(attempt, err);
            }
            if (err.status === 400 || err.status === 401) throw err;
            if (attempt < retries) {
                await new Promise(r => setTimeout(r, retryDelay));
            }
        }
    }
    throw lastError;
}

function getQueuedFileCount() {
    let count = 0;
    for (const entry of filesMap.values()) {
        if (!entry.removed) count++;
    }
    return count;
}

function initUpload() {
    const btn = document.getElementById("uploadbutton");
    btn.disabled = true;
    startUpload().catch(console.error).finally(() => btn.disabled = false);
}

async function startUpload() {
    if (!IS_UNLIMITED_FILES && getQueuedFileCount() > maxFilesRemaining) {
        showModal("maxfiles");
        return;
    }
    for (const entry of filesMap.values()) {
        if (entry.removed) continue;
        const {
            file,
            uuid,
            elements
        } = entry;
        // Disable delete during upload
        elements.removeBtn.remove();
        try {
            elements.progressText.textContent = "Reserving...";
            const serverUuid = await reserveChunk(elements);
            elements.progressText.textContent = "Uploading...";
            let offset = 0;
            // do-while so that add chunk is run for 0byte files as well
            do {
                const chunk = file.slice(offset, offset + CHUNK_SIZE);
                await withRetry(async () => {
                    const formData = new FormData();
                    formData.append("file", chunk);
                    formData.append("uuid", serverUuid);
                    formData.append("filesize", file.size);
                    formData.append("offset", offset);
                    const response = await fetch(UPLOAD_URL, {
                        method: "POST",
                        body: formData,
                        headers: {
                            apikey: API_KEY,
                            fileRequestId: FILE_REQUEST_ID
                        }
                    });
                    if (!response.ok) {
                        throw await parseErrorResponse(response);
                    }
                }, {
                    onRetry: (a, e) => {
                        elements.progressText.textContent = `Retry ${a}/3: ${e.message}`;
                    }
                });
                offset += chunk.size;
                if (file.size == 0) {
                    elements.progressBar.value = 1;
                    elements.progressText.textContent = "100%";
                } else {
                    elements.progressBar.value = offset;
                    elements.progressText.textContent = Math.floor((offset / file.size) * 100) + "%";
                }
            } while (offset < file.size);

            await finaliseUpload(file, serverUuid, elements);
            elements.progressText.textContent = "Completed";
            elements.item.style.opacity = "0.6";
            filesMap.get(uuid).removed = true;
            maxFilesRemaining = maxFilesRemaining - 1;
            if (maxFilesRemaining == 0) {
                showModal("alluploaded");
            }
        } catch (err) {
            elements.progressText.textContent = err.message || "Upload failed";
            elements.progressText.style.color = "#ff6b6b";
            elements.progressBar.style.display = "none";
        }
    }
}

async function parseErrorResponse(response) {
    const text = await response.text();
    let data = null;
    try {
        data = JSON.parse(text);
    } catch {
        /* not JSON */
    }
    if (data && data.Result === "error") {
        let message;
        switch (data.ErrorCode) {
            case 9:
                message = "File size limit exceeded";
                break;
            case 14:
                message = "Upload request has expired";
                showModal("expired");
                break;
            case 15:
                message = "Maximum file count reached";
                showModal("maxfilesdynamic");
                break;
            case 16:
                message = "Too many requests, please try again later";
                break;
            default:
                message = data.ErrorMessage || "Unknown upload error";
        }
        const err = new Error(message);
        err.status = response.status;
        err.code = data.ErrorCode;
        err.raw = data;
        return err;
    }
    // Fallback: plain text / non-JSON error
    const err = new Error(text || `HTTP ${response.status}`);
    err.status = response.status;
    return err;
}

async function reserveChunk(elements) {
    return withRetry(async () => {
        const response = await fetch(RESERVE_URL, {
            method: "POST",
            headers: {
                id: FILE_REQUEST_ID,
                apikey: API_KEY
            }
        });
        if (!response.ok) {
            throw await parseErrorResponse(response);
        }
        const data = await response.json();
        if (!data.Uuid) throw new Error("Invalid reserve response");
        return data.Uuid;
    }, {
        onRetry: (a, e) => {
            elements.progressText.textContent = `Retry ${a}/3: ${e.message}`;
        }
    });
}

async function finaliseUpload(file, uuid, elements) {
    await withRetry(async () => {
        const response = await fetch(COMPLETE_URL, {
            method: "POST",
            headers: {
                uuid,
                fileRequestId: FILE_REQUEST_ID,
                filename: encodeFilename(file.name),
                filesize: file.size,
                contenttype: file.type || "application/octet-stream",
                apikey: API_KEY
            }
        });
        if (!response.ok) {
            throw await parseErrorResponse(response);
        }
    }, {
        onRetry: (a, e) => {
            elements.progressText.textContent = `Retry ${a}/3: ${e.message}`;
        }
    });
}

function encodeFilename(name) {
    return "base64:" + Base64.encode(name);
}
  
</script>


{{ template "pagename" "PublicUpload"}}
{{ template "customjs" .}}
{{ template "footer"}}
{{end}}
