{{define "publicUpload"}}{{template "header" .}}

 
 <style>
 
.pu-file-list {
    margin-top: 1.5rem;
  }

  .pu-file-item {
    display: flex;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 0.95rem;
  }

  .pu-file-item .file-name {
    flex: 1;
    text-align: left;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    margin-right: 1rem;
  }


  .pu-file-item .upload-status {
    width: 350px; 
    text-align: right;
    margin-right: 1rem;
    flex-shrink: 0;
    opacity: 0.75;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .pu-file-item .file-size {
    width: 80px;
    text-align: right;
    margin-right: 12px;
    flex-shrink: 0;
    opacity: 0.75;
  }

</style>

<main style="margin-top: 2rem">
  <div class="row justify-content-center">
    <div class="col-lg-8">
      <div class="card bg-dark text-white">
        <div class="card-body">
          <h3 class="card-title text-center mb-4">Upload Files</h3>
{{ if ne .FileRequest.Notes "" }}
          <div class="info-box">
            <h6>Note</h6>
            <p class="mb-0">{{.FileRequest.Notes}}</p>
          </div>
{{ end }}
{{ if .FileRequest.HasRestrictions }}
          <div class="info-box">
            <h6>Upload restrictions</h6>
            <ul>
    {{ if not (.FileRequest.IsUnlimitedTime) }}
              <li>Upload possible until: <strong>
                  <span id="expirydate">{{ .FileRequest.Expiry }}</span>
                </strong>
              </li>
              <script>
                insertFormattedDate({{.FileRequest.Expiry}}, "expirydate");
              </script>
   {{ end }}
   {{ if or (not (.FileRequest.IsUnlimitedSize)) (lt .FileRequest.CombinedMaxSize 5000) }}
              <li>Maximum file size: <strong>
                  <span id="maxfilesize"></span>
                </strong>
              </li>
              <script>
                insertReadableSize({{.FileRequest.CombinedMaxSize}}, 1024 * 1024, "maxfilesize");
              </script>
   {{ end }}
       {{ if not (.FileRequest.IsUnlimitedFiles) }}
              <li>Maximum number of files: <strong>{{ .FileRequest.FilesRemaining }}</strong>
              </li>
       {{ end }}
            </ul>
          </div>
{{ end }}
          <label for="fileInput" class="upload-box text-center w-100">
            <p class="mb-2 fs-5">Drag & drop files here</p>
            <p class="mb-0 opacity-75">or paste or click to select</p>
            <input type="file" id="fileInput" class="d-none" multiple>
          </label>
          <div id="fileList" class="pu-file-list"></div>
          <div class="text-center mt-4">
            <button class="btn btn-primary" disabled onClick="initUpload();" id="uploadbutton"> Upload </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</main>


<!-- Error Modal -->
<div class="modal fade" id="errorModal" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
  <div class="modal-dialog gokapi-dialog">
    <div class="modal-content gokapi-dialog">
      <div class="modal-header">
        <h2 class="modal-title fs-5" id="errorModalLabel">Unable to upload</h2>
      </div>
      <div class="modal-body">
        <span id="span-modal-error"></span>
      </div>
      <div class="modal-footer">
        <button type="button" data-bs-dismiss="modal" data-bs-target="#errorModal" class="btn btn-primary">Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- All Uploaded Modal -->
<div class="modal fade" id="allUploadedModal" tabindex="-1" aria-labelledby="allUModalLabel" aria-hidden="true">
  <div class="modal-dialog gokapi-dialog">
    <div class="modal-content gokapi-dialog">
      <div class="modal-header">
        <h2 class="modal-title fs-5" id="allUModalLabel">Success</h2>
      </div>
      <div class="modal-body">
        All files have been successfully uploaded. No further files can be uploaded anymore. You can close this page now.
      </div>
      <div class="modal-footer">
      </div>
    </div>
  </div>
</div>



<script>

const fileInput = document.getElementById('fileInput');
const fileList = document.getElementById('fileList');
const filesMap = new Map();
const errorModal = new bootstrap.Modal(document.getElementById('errorModal'));


fileInput.addEventListener('change', () => {
    Array.from(fileInput.files).forEach(file => {

        if (file.size > MAX_FILE_SIZE) {
            document.getElementById('span-modal-error').innerText =
                `The file "${file.name}" exceeds the maximum allowed size of ${formatSize(MAX_FILE_SIZE)}.`;
            errorModal.show();
            return;
        }
	document.getElementById('uploadbutton').disabled = false;
        const uuid = getUuid();

        const item = document.createElement('div');
        item.className = 'pu-file-item';
        item.dataset.uuid = uuid;

        const name = document.createElement('span');
        name.textContent = file.name;
        name.className = 'file-name';

        const progressText = document.createElement('span');
        progressText.className = 'upload-status';
        progressText.textContent = 'Ready';

        const progressBar = document.createElement('progress');
        progressBar.className = 'upload-progress';
        
        if (file.size == 0) {
            progressBar.max = 1;
        } else {
            progressBar.max = file.size;
        }
        progressBar.value = 0;

        const size = document.createElement('span');
        size.className = 'file-size';
        size.textContent = formatSize(file.size);

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.title = 'Remove';
        removeBtn.className = 'btn btn-sm btn-link text-light p-0';
        removeBtn.innerHTML = '<i class="bi bi-x-circle"></i>';
        removeBtn.onclick = () => {
            filesMap.get(uuid).removed = true;
            item.remove();
        };

        item.append(name, progressText, progressBar, size, removeBtn);
        fileList.appendChild(item);

        filesMap.set(uuid, {
            uuid,
            file,
            removed: false,
            controller: new AbortController(),
            lastSpeed: "",
            elements: {
                progressBar,
                progressText,
                removeBtn,
                item
            }
        });
    });
    // Allow re-selecting same files
    fileInput.value = '';
});

function showModal(modalCode) {
    let message = "";
    switch (modalCode) {
    
        case "alluploaded":
            new bootstrap.Modal(document.getElementById('allUploadedModal'), {
                keyboard: false,
                backdrop: "static"
            }).show();
            return;
            
        case "maxfiles":
            if (maxFilesRemaining == 1) {
                message = "Too many files are selected for upload. Please only select 1 file.";
            } else {
                message = "Too many files are selected for upload. Please only select " + maxFilesRemaining + " files or fewer.";
            }
            break;
            
        case "maxfilesdynamic":
            message = "Some files could not be uploaded because the server rejected the request. This likely occurred because another user was uploading files at the same time and the maximum file limit was reached.";
            break;
            
        case "expired":
            message = "The upload request exceeded the permitted time limit, and uploading additional files is no longer possible.";
            break;
    }
    document.getElementById('span-modal-error').innerText = message;
    errorModal.show();
}

function formatSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let i = 0;
    while (bytes >= 1024 && i < units.length - 1) {
        bytes /= 1024;
        i++;
    }
    return bytes.toFixed(1) + ' ' + units[i];
}

const CHUNK_SIZE = {{.ChunkSize}} * 1024 * 1024;
const API_BASE = "./api/uploadrequest/chunk/";
const RESERVE_URL = API_BASE + "reserve";
const UNRESERVE_URL = API_BASE + "unreserve";
const UPLOAD_URL = API_BASE + "add";
const COMPLETE_URL = API_BASE + "complete";
const FILE_REQUEST_ID = "{{ .FileRequest.Id }}";
const API_KEY = "{{ .FileRequest.ApiKey }}";
const MAX_FILE_SIZE = {{.FileRequest.CombinedMaxSize}} * 1024 * 1024;
const IS_UNLIMITED_FILES = {{ .FileRequest.IsUnlimitedFiles }};
const IS_UNLIMITED_TIME = {{ .FileRequest.IsUnlimitedTime }};
var maxFilesRemaining = {{.FileRequest.FilesRemaining}};


async function withRetry(fn, {
    retries = 3,
    retryDelay = 5000,
    onRetry,
    signal} = {}) {
    let lastError;
    for (let attempt = 1; attempt <= retries; attempt++) {
        // Exit if cancelled
        if (signal && signal.aborted) throw new Error("Cancelled");

        try {
            return await fn();
        } catch (err) {
            lastError = err;
            if (err.message === "Cancelled" || (signal && signal.aborted)) throw err; // Don't retry cancellations
            
            if (onRetry && attempt < retries) {
                onRetry(attempt, err);
            }
            if (err.status === 400 || err.status === 401) throw err;
            if (attempt < retries) {
                await new Promise(r => setTimeout(r, retryDelay));
            }
        }
    }
    throw lastError;
}

function getQueuedFileCount() {
    let count = 0;
    for (const entry of filesMap.values()) {
        if (!entry.removed) count++;
    }
    return count;
}

function initUpload() {
    const btn = document.getElementById("uploadbutton");
    btn.disabled = true;
    startUpload().catch(console.error).finally(() => {
        // Check if there are still files pending (failed uploads)
        // If count > 0, re-enable button. If 0, keep it disabled.
        if (getQueuedFileCount() > 0) {
            btn.disabled = false;
        }
    });
}

async function startUpload() {
    if (!IS_UNLIMITED_FILES && getQueuedFileCount() > maxFilesRemaining) {
        showModal("maxfiles");
        return;
    }

    for (const entry of filesMap.values()) {
        if (entry.removed) continue;
        const {
            file,
            uuid,
            elements
        } = entry;

        // Reset UI state for (re)attempt
        elements.progressBar.style.display = "";
        elements.progressText.style.color = "";
        let lastSpeedText = "";

        try {
            elements.progressText.textContent = "Reserving...";
            const serverUuid = await reserveChunk(elements);
            entry.serverUuid = serverUuid;

            // Change button to "Cancel" once we have a reservation
            elements.removeBtn.innerHTML = '<i class="bi bi-stop-circle text-danger"></i>';
            elements.removeBtn.title = "Cancel Upload";
            elements.removeBtn.onclick = async () => {
                entry.controller.abort(); // Triggers the abort signal
                await unreserve(serverUuid);
                entry.removed = true;
                elements.item.remove();
            };

            let offset = 0;
            // do-while so that add chunk is run for 0byte files as well
            do {
                if (entry.controller.signal.aborted) return;
                const chunk = file.slice(offset, offset + CHUNK_SIZE);

                await withRetry(async () => {
                    return new Promise((resolve, reject) => {
                        const formData = new FormData();
                        formData.append("file", chunk);
                        formData.append("uuid", serverUuid);
                        formData.append("filesize", file.size);
                        formData.append("offset", offset);

                        const xhr = new XMLHttpRequest();
                        entry.xhr = xhr;
                        xhr.open("POST", UPLOAD_URL);
                        xhr.setRequestHeader("apikey", API_KEY);
                        xhr.setRequestHeader("fileRequestId", FILE_REQUEST_ID);

                        const startTime = Date.now();

                        // Listen for the cancel signal
                        const abortHandler = () => {
                            xhr.abort();
                            reject(new Error("Cancelled"));
                        };
                        entry.controller.signal.addEventListener('abort', abortHandler);

                        xhr.upload.onprogress = (event) => {
                            if (event.lengthComputable) {
                                const chunkOffset = offset + event.loaded;
                                const totalSize = file.size === 0 ? 1 : file.size;
                                const percent = Math.floor((chunkOffset / totalSize) * 100);

                                const duration = (Date.now() - startTime) / 1000;
                                if (duration > 0) {
                                    // Update the persistent lastSpeedText
                                    lastSpeedText = ` (${formatSize(event.loaded / duration)}/s)`;
                                }

                                elements.progressBar.value = chunkOffset;
                                elements.progressText.textContent = percent + "%" + lastSpeedText;
                            }
                        };

                        xhr.onload = async () => {
                            entry.controller.signal.removeEventListener('abort', abortHandler);
                            if (xhr.status >= 200 && xhr.status < 300) resolve();
                            else reject(await parseXhrError(xhr));
                        };

                        xhr.onerror = () => {
                            entry.controller.signal.removeEventListener('abort', abortHandler);
                            reject(new Error("Network Error"));
                        };

                        xhr.send(formData);
                    });
                }, {
                    signal: entry.controller.signal,
                    onRetry: (a, e) => {
                        // Keep the speed text visible during retries
                        elements.progressText.textContent = `Retry ${a}/3: ${e.message}${lastSpeedText}`;
                    }
                });

                offset += chunk.size;
            } while (offset < file.size);

            await finaliseUpload(file, serverUuid, elements);

            elements.progressText.textContent = "Completed";
            elements.item.style.opacity = "0.6";
            elements.removeBtn.remove(); // Remove button only on success

            filesMap.get(uuid).removed = true;
            maxFilesRemaining--;

            if (maxFilesRemaining === 0) showModal("alluploaded");

        } catch (err) {
            if (err.message === "Cancelled" || entry.controller.signal.aborted) return;

            elements.progressText.textContent = err.message || "Upload failed";
            elements.progressText.style.color = "#ff6b6b";
            elements.progressBar.style.display = "none";

            // Change button to "Trash" for failed uploads to allow removal
            elements.removeBtn.innerHTML = '<i class="bi bi-trash"></i>';
            elements.removeBtn.title = "Remove from list";
            elements.removeBtn.onclick = async () => {
                if (entry.serverUuid) await unreserve(entry.serverUuid);
                entry.removed = true;
                elements.item.remove();
            };
        }
    }
}

async function parseErrorResponse(response) {
    const text = await response.text();
    let data = null;
    try {
        data = JSON.parse(text);
    } catch {
        /* not JSON */
    }
    if (data && data.Result === "error") {
        let message;
        switch (data.ErrorCode) {
            case 9:
                message = "File size limit exceeded";
                break;
            case 14:
                message = "Upload request has expired";
                showModal("expired");
                break;
            case 15:
                message = "Maximum file count reached";
                showModal("maxfilesdynamic");
                break;
            case 16:
                message = "Too many requests, please try again later";
                break;
            default:
                message = data.ErrorMessage || "Unknown upload error";
        }
        const err = new Error(message);
        err.status = response.status;
        err.code = data.ErrorCode;
        err.raw = data;
        return err;
    }
    // Fallback: plain text / non-JSON error
    const err = new Error(text || `HTTP ${response.status}`);
    err.status = response.status;
    return err;
}

async function reserveChunk(elements) {
    return withRetry(async () => {
        const response = await fetch(RESERVE_URL, {
            method: "POST",
            headers: {
                id: FILE_REQUEST_ID,
                apikey: API_KEY
            }
        });
        if (!response.ok) {
            throw await parseErrorResponse(response);
        }
        const data = await response.json();
        if (!data.Uuid) throw new Error("Invalid reserve response");
        return data.Uuid;
    }, {
        onRetry: (a, e) => {
            elements.progressText.textContent = `Retry ${a}/3: ${e.message}`;
        }
    });
}

async function finaliseUpload(file, uuid, elements) {
    await withRetry(async () => {
        const response = await fetch(COMPLETE_URL, {
            method: "POST",
            headers: {
                uuid,
                fileRequestId: FILE_REQUEST_ID,
                filename: encodeFilename(file.name),
                filesize: file.size,
                nonblocking: true,
                contenttype: file.type || "application/octet-stream",
                apikey: API_KEY
            }
        });
        if (!response.ok) {
            throw await parseErrorResponse(response);
        }
    }, {
        onRetry: (a, e) => {
            elements.progressText.textContent = `Retry ${a}/3: ${e.message}`;
        }
    });
}

function encodeFilename(name) {
    return "base64:" + Base64.encode(name);
}
  


async function unreserve(uuid) {
    if (!uuid) return;
    try {
        await fetch(UNRESERVE_URL, {
            method: "POST",
            headers: { 
                uuid: uuid,
                apikey: API_KEY,
                id: FILE_REQUEST_ID 
            },
            keepalive: true // Crucial for calls during page unload
        });
    } catch (e) { console.error("Unreserve failed", e); }
}

// Confirm before closing tab
window.addEventListener('beforeunload', (e) => {
    const uploading = Array.from(filesMap.values()).some(f => !f.removed);
    if (uploading) {
        // Standard way to trigger a "Are you sure?" browser dialog
        e.preventDefault();
        e.returnValue = ''; 
    }
});

// Attempt unreserve on actual exit
window.addEventListener('unload', () => {
    for (const entry of filesMap.values()) {
        if (!entry.removed && entry.serverUuid) {
            unreserve(entry.serverUuid);
        }
    }
});

</script>

{{ template "pagename" "PublicUpload"}}
{{ template "customjs" .}}
{{ template "footer"}}
{{end}}
