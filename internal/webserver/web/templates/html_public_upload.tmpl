{{define "publicUpload"}}{{template "header" .}}



<style>
 

  .file-list {
    margin-top: 1.5rem;
  }

.file-item {
  display: flex;
  align-items: center;
  padding: 0.5rem 0;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  font-size: 0.95rem;
}

.file-item span:first-child {
  flex: 1;
  text-align: left; 
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.file-size {
  text-align: right;
  margin-right: 12px;
  flex-shrink: 0;
    opacity: 0.75;
}

</style>

<main style="margin-top: 2rem">
  <div class="row justify-content-center">
    <div class="col-lg-8">

      <div class="card bg-dark text-white">
        <div class="card-body">

          <h3 class="card-title text-center mb-4">Upload Files</h3>

{{ if ne .FileRequest.Notes "" }}
          <div class="info-box">
            <h6>Note</h6>
            <p class="mb-0">
              {{.FileRequest.Notes }}
            </p>
          </div>
 {{ end }}

{{ if .FileRequest.HasRestrictions }}
          <div class="info-box">
            <h6>Upload restrictions</h6>
            <ul>
    {{ if not (.FileRequest.IsUnlimitedTime) }}
              <li>Upload possible until: <strong><span id="expirydate">{{ .FileRequest.Expiry }}</span></strong></li>
              <script>insertFormattedDate({{ .FileRequest.Expiry }}, "expirydate");</script>
    {{ end }}
    {{ if or  (not (.FileRequest.IsUnlimitedSize)) (lt .FileRequest.CombinedMaxSize 5000) }}
              <li>Maximum file size: <strong><span id="maxfilesize"></span></strong></li>
              <script>insertReadableSize({{ .FileRequest.CombinedMaxSize }}, 1024 * 1024, "maxfilesize");</script>
              
    {{ end }}
    {{ if not (.FileRequest.IsUnlimitedFiles) }}
              <li>Maximum number of files: <strong>{{ .FileRequest.FilesRemaining }}</strong></li>
    {{ end }}
            </ul>
          </div>
{{ end }}


          <label for="fileInput" class="upload-box text-center w-100">
            <p class="mb-2 fs-5">Drag & drop files here</p>
            <p class="mb-0 opacity-75">or paste or click to select</p>
            <input
              type="file"
              id="fileInput"
              class="d-none"
              multiple
            >
          </label>

          <div id="fileList" class="file-list"></div>

          <div class="text-center mt-4">
            <button class="btn btn-secondary" onClick="initUpload();" id="uploadbutton">
              Upload
            </button>
          </div>

        </div>
      </div>

    </div>
  </div>
</main>

<script>
  const fileInput = document.getElementById('fileInput');
const fileList = document.getElementById('fileList');

const filesMap = new Map();

fileInput.addEventListener('change', () => {
  Array.from(fileInput.files).forEach(file => {
    const uuid = getUuid();

    const item = document.createElement('div');
    item.className = 'file-item';
    item.dataset.uuid = uuid;

    const name = document.createElement('span');
    name.textContent = file.name;

    const progressText = document.createElement('span');
    progressText.className = 'file-size';
    progressText.textContent = '0%';

    const progressBar = document.createElement('progress');
    progressBar.max = file.size;
    progressBar.value = 0;
    progressBar.style.width = '120px';
    progressBar.style.marginRight = '10px';

    const size = document.createElement('span');
    size.className = 'file-size';
    size.textContent = formatSize(file.size);

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.title = 'Remove';
    removeBtn.className = 'btn btn-sm btn-link text-light p-0';
    removeBtn.innerHTML = '<i class="bi bi-x-circle"></i>';

    removeBtn.addEventListener('click', () => {
      filesMap.get(uuid).removed = true;
      item.remove();
    });

    item.append(name, progressBar, progressText, size, removeBtn);
    fileList.appendChild(item);

    filesMap.set(uuid, {
      uuid,
      file,
      removed: false,
      elements: { progressBar, progressText, removeBtn, item }
    });
  });

  // Allow re-selecting same files
  fileInput.value = '';
});


  function formatSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let i = 0;
    while (bytes >= 1024 && i < units.length - 1) {
      bytes /= 1024;
      i++;
    }
    return bytes.toFixed(1) + ' ' + units[i];
  }
</script>


<script>
const CHUNK_SIZE = {{ .ChunkSize }} * 1024 * 1024;
const UPLOAD_URL = "./api/uploadrequest/chunk/add";
const COMPLETE_URL = "./api/uploadrequest/chunk/commplete";

const FILE_REQUEST_ID = "{{ .FileRequest.Id }}";
const API_KEY = "{{ .FileRequest.ApiKey }}";

function initUpload() {
  const btn = document.getElementById("uploadbutton");
  btn.disabled = true;

  startUpload()
    .catch(err => console.error(err))
    .finally(() => btn.disabled = false);
}

async function startUpload() {
  for (const entry of filesMap.values()) {
    if (entry.removed) continue;

    const { file, uuid, elements } = entry;

    // Disable delete during upload
    elements.removeBtn.remove();

    let offset = 0;

    while (offset < file.size) {
      const chunk = file.slice(offset, offset + CHUNK_SIZE);

      const formData = new FormData();
      formData.append("file", chunk);
      formData.append("uuid", uuid);
      formData.append("filesize", file.size);
      formData.append("offset", offset);

      const response = await fetch(UPLOAD_URL, {
        method: "POST",
        body: formData,
        headers: {
          apikey: API_KEY,
          fileRequestId: FILE_REQUEST_ID
        }
      });

      if (!response.ok) {
        elements.progressText.textContent = "Error";
        throw new Error(`Chunk upload failed: ${response.status}`);
      }

      offset += chunk.size;
      elements.progressBar.value = offset;
      elements.progressText.textContent =
        Math.floor((offset / file.size) * 100) + "%";
    }

    await finalizeUpload(file, uuid);

    elements.progressText.textContent = "Completed";
    elements.item.style.opacity = "0.6";
    filesMap.get(uuid).removed = true;
  }
}

async function finalizeUpload(file, uuid) {
  const response = await fetch(COMPLETE_URL, {
    method: "POST",
    headers: {
      uuid: uuid,
      fileRequestId: FILE_REQUEST_ID,
      filename: encodeFilename(file.name),
      filesize: file.size,
      contenttype: file.type || "application/octet-stream",
      apikey: API_KEY
    }
  });

  if (!response.ok) {
    throw new Error(`Finalize failed: ${response.status}`);
  }
}

function encodeFilename(name) {
  return "base64:" + Base64.encode(name);
}
</script>

{{ template "pagename" "PublicUpload"}}
{{ template "customjs" .}}
        
{{template "footer"}}    
{{end}}
